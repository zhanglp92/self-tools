
## 学习资料

[设计模式也可以这么简单](https://mp.weixin.qq.com/s/pjQ6xqDvHHlfANUW_o2dTQ)

### 创建型模式

| 方式 | 特性 | 案例 | 备注 |
| -- | -- | -- | -- |
| 工厂模式(XxxFactory) | 指责单一,只负责生产各种对象 | 生产不同品牌电脑 |
| 建造者模式(XxxBuilder) | 适用于多属性场景 |
| 原型模式(clone) | Java的克隆为浅克隆,需要继承Cloneable接口 |

> 创建型模式总体上比较简单，它们的作用就是为了产生实例对象，算是各种工作的第一步了，因为我们写的是面向对象的代码，所以我们第一步当然是需要创建一个对象了。
简单工厂模式最简单；工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂；抽象工厂模式有产品族的概念，如果各个产品是存在兼容性问题的，就要用抽象工厂模式。单例模式就不说了，为了保证全局使用的是同一对象，一方面是安全性考虑，一方面是为了节省资源；建造者模式专门对付属性很多的那种类，为了让代码更优美；原型模式用得最少，了解和 Object 类中的 clone() 方法相关的知识即可。

### 结构型模式

| 方式 | 特性 | 案例 | 备注 |
| -- | -- | -- | -- |
| 代理模式(XxxProxy) | 方法增强 |
| 适配器模式(XxxAdapter) | 把鸡包装成鸭这种用来适配接口 |
| 桥梁模式 | 做到了很好的解耦 |
| 装饰模式 | 
| 门面模式 | 封装所有实例化的过程 | slf4j |
| 组合模式 | 具有明显的层次结构 |
| 享元模式 | 对象复用 |

> 适配器模式和代理模式的异同：
>> 比较这两种模式，其实是比较对象适配器模式和代理模式，在代码结构上，它们很相似，都需要一个具体的实现类的实例。但是它们的目的不一样，代理模式做的是增强原方法的活；适配器做的是适配的活，为的是提供“把鸡包装成鸭，然后当做鸭来使用”，而鸡和鸭它们之间原本没有继承关系。

#### 适配器模式

* 默认适配器：接口继承
* 对象适配器：接口继承, 将对象传入
* 类适配器：类继承

> 结构型模式总结：
>> 代理模式是做方法增强的，适配器模式是把鸡包装成鸭这种用来适配接口的，桥梁模式做到了很好的解耦，装饰模式从名字上就看得出来，适合于装饰类或者说是增强类的场景，门面模式的优点是客户端不需要关心实例化过程，只要调用需要的方法即可，组合模式用于描述具有层次结构的数据，享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能。

### 行为型模式

| 方式 | 特性 | 案例 | 备注 |
| -- | -- | -- | -- |
| 策略模式 | 类型与桥梁模式 |
| 观察者模式 | 消息通知机制 |
| 责任链模式 | | 审批流 |
| 模板方法模式 | 
| 状态模式 |

> 行为型模式总结：
>> 行为型模式部分介绍了策略模式、观察者模式、责任链模式、模板方法模式和状态模式，其实，经典的行为型模式还包括备忘录模式、命令模式等，但是它们的使用场景比较有限，而且本文篇幅也挺大了，我就不进行介绍了。

### 其他

* 单例模式：经典的嵌套类模式
* 代码简化使用 lombok
* 单机观察者模式, 消息同步 Guava 中的 EventBus