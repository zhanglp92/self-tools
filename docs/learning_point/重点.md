[toc]
---

## Spring原理

### Spring IOC (Inversion of Control)

IOC既为控制反转, 那么谁被谁控制, 谁又把谁做了反转?

* 反转: Spring改变了传统的应用程序为老大的思想, 以主为客抢占了应用的控制权. 即应用程序和工具发生了逆转.

* 控制: 由于Spring抢占先机, 应用程序被动释权, 完全由Spring托管. 即Spring控制应用程序.

#### Bean

既然应用程序被Spring全权控制, 那么应用应该以什么样的形式呈现呢. 即容器.

##### 容器的生命周期

![Bean生命周期-基本](https://pic3.zhimg.com/80/v2-2a8565eb02d88025d0fbe1015ef323d6_1440w.jpg)

![Bean生命周期-全部](https://pic3.zhimg.com/80/v2-e4fa050899e7207e7b13f2f911779781_1440w.jpg)

| 接口 | 作用 | 备注 |
| -- | -- | -- |
| BeanNameAware | 

这个问题 最好可以多说一点，比如 对于IOC，不妨把Bean 如何加载、如何初始化以及如何注册到IOC容器中的详细过程说一下， 涉及BeanDefinition、BeanFactory也深入细节聊一下。

一个请求过来在Spring中发生了哪些事情。
这个问题不妨把一个请求过来在TCP层面上建立连接、操作系统如何处理连接、Web容器接收到连接对象后做了哪些事情、Spring 如何对接收到的请求进行处理都说一下，当然最终还是落在Spring 容器内部如何处理一个请求，这个过程一定要说清楚，需要体现细节。在说前面的内容的时候，可以放心面试官不会打断你。

### Spring AOP (aspect object programming)

优点：原有代码无需更改，不影响原有业务逻辑;

缺点：通过代理方式，会有一定的性能损失;(简单测试, 调用10W次, 无注解 8ms, 有注解 620ms)

功能： 让关注点代码与业务代码分离！

面向切面编程就是指： 对很多功能都有的重复的代码抽取，再在运行的时候往业务方法上动态植入“切面类代码”。

正常: doAround before --> doBefore --> doAround after --> doAfter --> doAfterReturning

异常: doAround before --> doBefore --> doAfter --> doAfterThrowing

#### Spring AOP 自定义注解生效范围

* 条件1: 被Spring托管的实例
* 条件2: 由Spring托管实例主动调用方法.(this调用不生效)
* 条件3: 方法只能是 protected 或 public

以上限制条件根本原因是因为:
1. 执行注解代码时, 实例为代理对象非目标本身;
2. CGLIB基于继承实现, 无法继承final或private;

解决this调用不生效的方法:
1. 从Spring中找出托管的实例, 因为这里的实例已经是被代理包裹的目标了
2. 通过 AopContext.currentProxy() 方法获取当前代理

流程:
1. Spring托管实例注解方法调用
2. 进入CGLIB动态代理

CGLIB代理内部: 
* 获取注解实现的方法列表;(这里首次调用后, 会为每个注解方法添加缓存)
* 代理内部已经指定好了方法调用顺序, 按照规定的顺序向下执行;

Spring获取到的方法列表顺序: 
* doAfterThrowing
* doAfterReturning
* doAfter
* doAround
* doBefore

### SpringBoot 启动过程

这个主要是从它基于Spring的事件发布和监听机制开始说起 就没什么问题。

## 数据结构

### 入门题目

实现一个栈，push，pop方法，以及 max(获取最大的元素) 方法，要求时间复杂度为 O(1)。

实现一个单链表，你会如何实现；比如，你可能会定义一个Node节点，里面有当前节点的key和value，还有对于下一个节点的引用。如果熟悉jdk对于各种数据结构的实现，这道题是很容易过的。

### 源码理解

jdk中对于 List、Stack、Tree、Set 的实现，

### ThreadLocal

* 本质: 就是一个工具类
* 工作: 当前线程从ThreadLocal实例读/写数据时, 它负责读/写当前线程的ThreadLocalMap
* 特性: 线程安全, 同一个实例不同线程调用, 使用的是当前线程独拥有的数据, 可以有效的避免一些参数的传递
* 应用场景: 例Spring AOP 中 AopContext.currentProxy() 方法

### ThreadLocalMap

* 本质: 用数组实现的一个Map
* 案例: Thread存储线程独有变量
* hash: 种子数计算HashCode, 和数组长度&运算得到数组下标, 将数据添加到此处
* hash冲突: 如果hash计算的下标非当前KEY, 则顺序向后查找, 如果超出数组长度, 则oldSize*2扩展

#### HashMap

在jdk1.8之后，HashMap除了数组+链表之外，引用了红黑树。那么好了，你需要说明 对于 引用了红黑树的 HashMap 如何put一个元素，以及链表是在何时转化为红黑树的。比如，首先需要知道这个元素落在哪一个数组里，获取hashcode后并不是对数组长度取余来确定的，而是高低位异或求与来得到的。这个地方首先得知道异或求与是做什么样的运算的。

之后说一下在HashMap中的实现，比如hashcode无符号右移16位后和原hashcode做异或运算，这相当于把hashcode的高16位拿过来和hashcode的低16位做异或运算，因为无符号右移后前面说的16位都补零，这就是前面说的 "高低位异或“，进而是“求与”，和谁求与呢，和数组长度减1 求与。说到这里起码能够证明你是看过源码的，接下来说说你的思考，比如我们知道对于hashmap 初始化容量决定了数组大小，一般我们对于数组这个初始容量的设置是有规律的，它应该是 2^n 。这个初始容量的设置影响了HashMap的效率，那又涉及到影响HashMap效率的主要因素，比如初始容量和负载因子。

当已用数组达到容量与负载因子的乘积之后会进行一个rehash的过程，这个地方涉及到的如何rehash及各种算法如果有时间也是可以说的，没有时间不说也没有关系。回到刚才说的 2^n, 可以说说它为什么是2^n。

当我们说什么东西为什么是这样的时候，我们一般从两个⻆度考虑，一个是：这样做有什么好处，另一个是：不这样做有什么坏处。我们刚才说到“求与”这个过程，如果不是 2^n, 会导致较多的哈希碰撞(具体原因可以自己分析一下或者百度一下)，这个会影响HashMap的效率。说完上面这些，既表明你看过源码，又表明你有自己的思考了，当然也可以进一步说说它是在什么条件下以及如何进行扩容的（如果时间允许，并且面试官也有耐心继续听下去）。

对于put操作，这才只是第一步，找到数组的位置，接下来 要看这个位置也没有元素，如果没有，直接放进去就可以，如果有，要看怎么放进去，jdk1.8中 对于HashMap的实现中，是基于Node(链表节点) 和TreeNode(红黑树节点) 的，当然它们继承了Entry。

那么，如果数组当前位置已经有了元素，就得知道这个元素是链表的节点还是红黑树的节点，以便进一步确认接下来要put的元素是以链表的方式插入，还是以红黑树的方式插入，这个地方在源码中进入了一个类型的判断，如果是链表的节点，就以链表的方式把要put的节点插入到next为null的节点上，如果是红黑树的节点，就要以红黑树的方式插入一个节点。

接下来其实不是考察的重点，但是也可以说说，就是:

(1) 为什么要引入红黑树，

(2)如何在红黑树中插入一个节点。对于这两个问题，首先，引入红黑树的好处是为了提高查询效率，要说出O(log2(n))，但是在提高查找效率的同时 也在插入的时候更加耗时，那可以说一下为什么更加耗时，自然带出第二个问题，如何在红黑树中插入一个节点，比如 当插入一个节点的时候我们会默认它是红色的(这个地方可以结合红黑树特点说一下 我们为什么默认它是红色的，从黑色高度以及相邻两节点不同为红色入手)，插入后如果父节点是黑色的 就不需要动了，但假如是红色的，就需要进行左旋和右旋操作，如果很了解，可以细说左旋右旋如何实现，如果不是很了解，到此为止也ok。

说到这里，我们忽略了一个重要的点，就是链表转换为红黑树的条件，说出链表长度到8(相当于红黑树开始第四层) 以及 数组大小达到64就已经够了，也可以进一步说一下 链表是如何转换为红黑树的。说完也可以说一下 ConcurrentHashMap中也是一样的，然后接下来就引入对ConcurrentHashMap的理解，⽐如 在什么地⽅会涉及到线程安全问题 以及ConcurrentHashMap是如何解决的，说说CAS，说完CAS再说说AQS，自由发挥吧。

## JVM

### JVM内存结构

这个问题需要你能画出JVM内存结构的图，画出方法区、堆、程序计算器、虚拟机栈、本地方法栈，并说出每一个部分具体是什么作用，比如，哪些是线程共享的，哪些是线程独享的，哪些地方存放了什么数据，为什么会这样存放，哪些虚拟机参数对这些空间大小是有影响的，可以如何配置。这些都比较常规。

### JVM四种引入类型

这个问题比较简单，强引入、弱引入、软引入、虚引入，说一下它们各自的特点和GC对它们的不同处理方式，再说一下常用的应用场景或者jdk的实现中对它们的使用，比如，ThreadLocal 的静态内部类ThreadLocalMap，它的Key是弱引用的，也可以说一下 在你的理解中 为什么它是弱引用的，假如不是会怎么样。


## 创建型模式

手写一个单例
这个基本上大多数公司都会考察的。要写一个基于懒汉式的双重检测的单例。单例有三个比较关键的点，一是私有构造方法，避免外部new出对象；二是保证唯一性；三是提供一个全局访问点。

另外，懒汉式双重检测的实现方式 有三点需要注意的地方，一是 全局访问点必须是静态的，外界使用可以通过类直接调用，二是在进入锁之后还需要校验，三是保存单例对象的私有变量一定要用volatile修饰，这个地方可以多说一些，比如volatile防止指令重排序，保证内存可见性(JVM层面和CPU层面可以分别说)。volatile 这个地方能说的东西还是很多的，基本上可以与面试官再聊二十分钟了。


## 行为型模式

类加载过程
加载 链接 初始化，链接又分为验证准备和解析，每一个阶段是做了什么要说清楚。Object a = new Object()；这行代码做了哪些事情，需要从类加载开始说起，这个相当于上一问题的延续，所以一定要清楚每一个环节做了哪些事情的，否则这个问题不可能说清楚。

说完类加载的过程，再说一下开辟内存空间、初始化内存空间以及把内存地址赋值给变量a，接下来可以进一步说一下JVM或者CPU层面对指令的优化，以及在某些时刻我们需要避免它做这样的优化，比如在单例中我们的实例需要用volatile修饰避免指令重排序(可以说一下在new一个对象的过程中如果指令重排序了会导致什么结果)。

## 工具

接下来主要是对过往项目中用到的框架、工具的考察
maven的熟练程度
比如问问 有哪些类型
Linux命令⾏的熟练程度
比如 问问 ${} 和 $() 区别
消息队列的熟练程度
比如问问Kafka分区，如何分区 等等(因为我过往项⽬经验中写了kafka，所以才会被问及，如果写了其他消息队列，也可能会被问及)
Netty
从NIO开始说 肯定是没错的，再说说Netty的实现⽅式，以及它除了IO之外还⼲了哪些事情。